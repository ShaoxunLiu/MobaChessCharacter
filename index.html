<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è§’è‰²å¡ - å®Œç¾ç§»åŠ¨ç«¯é€‚é…ç‰ˆ</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        /* CSS æ ·å¼éƒ¨åˆ† */
        :root {--primary: #4a90e2;--bg: #f0f2f5;--card-bg: #ffffff;--text: #333;--border: #e1e4e8;--accent: #ff6b6b;--gem-color: #9b59b6;}
        body {font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;background-color: var(--bg);color: var(--text);margin: 0;padding: 0;height: 100vh;overflow: hidden;display: flex;justify-content: center;align-items: center;}
        
        #app {
            width: 100%;
            height: 100%;
            max-width: 500px;
            background: var(--card-bg);
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            overflow-y: auto; 
            /* å…è®¸åˆ—è¡¨æ»šåŠ¨ï¼Œä½†ç¦æ­¢åŒå‡»ç¼©æ”¾ */
            touch-action: pan-y manipulation; 
            user-select: none;
            -webkit-user-select: none; /* iOS Safari */
        }

        /* ğŸŒŸ ä¿®å¤ 1: å¼ºåˆ¶æ‰€æœ‰æŒ‰é’®ç¦æ­¢åŒå‡»ç¼©æ”¾è¡Œä¸º */
        button {
            touch-action: manipulation;
        }
        
        /* æ ‡ç­¾é¡µå¯¼èˆªæ ·å¼ */
        .tabs {
            display: flex;
            justify-content: space-around;
            margin: -20px -20px 20px -20px; 
            padding: 10px 20px 0 20px;
            border-bottom: 2px solid var(--border);
            background-color: var(--card-bg);
            position: sticky; 
            top: 0;
            z-index: 10;
        }
        .tab-button {
            padding: 10px 15px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            color: var(--text);
            background-color: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            transition: border-bottom 0.3s, color 0.3s;
        }
        .tab-button.active {
            border-bottom: 3px solid var(--primary);
            color: var(--primary);
        }

        /* è§’è‰²å¡åŸå§‹å†…å®¹çš„æ ·å¼ */
        .header {text-align: center;margin-bottom: 15px;}
        .header h1 {font-size: 24px;margin: 0;color: var(--primary);}
        .input-group {margin-bottom: 15px;}
        .input-group label {display: block;font-weight: bold;margin-bottom: 5px;font-size: 14px;}
        .input-group input[type="text"] {width: 100%;padding: 10px;border: 1px solid var(--border);border-radius: 6px;box-sizing: border-box;font-size: 16px;}
        
        /* å±æ€§åŒºåŸŸ */
        .stats-area {border: 1px solid var(--border);border-radius: 8px;padding: 15px;margin-bottom: 20px;}
        .stats-area h2 {font-size: 18px;margin-top: 0;padding-bottom: 5px;border-bottom: 1px solid var(--border);}
        .stat-item {display: flex;justify-content: space-between;align-items: center;margin-bottom: 10px;padding: 5px 0;border-bottom: 1px dotted var(--border);}
        .stat-name {font-weight: bold;width: 80px;}
        .stat-value {display: flex;align-items: center;}
        .stat-value button {width: 30px;height: 30px;font-size: 18px;line-height: 1;border: none;border-radius: 4px;cursor: pointer;background-color: var(--primary);color: white;margin: 0 5px;transition: background-color 0.2s;}
        .stat-value button:disabled {background-color: #ccc;cursor: not-allowed;}
        .stat-value button:active:not(:disabled) {background-color: #3873c9;}
        .stat-points {width: 25px;text-align: center;font-weight: bold;font-size: 16px;}

        /* æ´¾ç”Ÿå±æ€§/HP/å®çŸ³ */
        .derived-hp-gem {display: grid;grid-template-columns: repeat(2, 1fr);gap: 10px;margin-bottom: 20px;}
        .derived-item, .hp-item, .gem-item {border: 1px solid var(--border);border-radius: 6px;padding: 10px;text-align: center;}
        .derived-item strong, .hp-item strong, .gem-item strong {display: block;font-size: 14px;margin-bottom: 5px;color: #666;}
        .derived-value, .hp-value {font-size: 20px;font-weight: bold;color: var(--primary);}
        .gem-value {font-size: 20px;font-weight: bold;color: var(--gem-color);}
        
        /* HP è°ƒæ•´ */
        .hp-adjust {display: flex;justify-content: center;align-items: center;margin-top: 5px;}
        .hp-adjust input {width: 40px;text-align: center;border: 1px solid var(--border);border-radius: 4px;margin: 0 5px;}
        .hp-adjust button {padding: 5px 10px;border: none;border-radius: 4px;cursor: pointer;background-color: var(--accent);color: white;margin: 0 5px;transition: background-color 0.2s;}
        .hp-adjust button.heal {background-color: #2ecc71;}
        .hp-adjust button:active {opacity: 0.8;}
        
        .current-hp-value {color: var(--accent);}

        /* å®çŸ³è°ƒæ•´ */
        .gem-adjust {display: flex;justify-content: center;margin-top: 5px;}
        .gem-adjust button {padding: 5px 10px;border: none;border-radius: 4px;cursor: pointer;background-color: var(--gem-color);color: white;margin: 0 5px;transition: background-color 0.2s;}
        .gem-adjust button:active {opacity: 0.8;}

        /* å¤‡æ³¨åŒºåŸŸ */
        .notes-area textarea {width: 100%;height: 100px;padding: 10px;border: 1px solid var(--border);border-radius: 6px;box-sizing: border-box;font-size: 14px;resize: vertical;}

        /* æŠ€èƒ½æ ‘éƒ¨åˆ† */
        .skill-tree-content {padding-top: 10px;}
        .skill-tree-content select {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid var(--border);
            border-radius: 6px;
            box-sizing: border-box;
            font-size: 16px;
        }
        .skill-tree-image-container {
            width: 100%;
            height: 400px; 
            border: 1px solid var(--border);
            border-radius: 6px;
            background-color: #f9f9f9;
            box-sizing: border-box;
            padding: 10px;
            overflow: hidden; 
            position: relative;
        }
        .skill-tree-image-container img {
            max-width: none;
            width: 100%; 
            min-width: 300px; 
            display: block;
            
            /* ğŸŒŸ ä¿®å¤ 2: ç¦ç”¨æµè§ˆå™¨é»˜è®¤è§¦æ‘¸è¡Œä¸ºï¼Œå®Œå…¨ç”± JS æ¥ç®¡ */
            touch-action: none; 
            
            user-select: none;
            -webkit-user-select: none;
            transform-origin: 0 0;
            cursor: grab; 
        }
        .skill-tree-image-container img.is-dragging {
            cursor: grabbing;
        }
    </style>
</head>
<body>

<div id="app">
    <div class="tabs">
        <button class="tab-button" :class="{ active: currentTab === 'charCard' }" @click="currentTab = 'charCard'">
            è§’è‰²å¡
        </button>
        <button class="tab-button" :class="{ active: currentTab === 'skillTree' }" @click="currentTab = 'skillTree'">
            æŠ€èƒ½æ ‘
        </button>
    </div>

    <div v-if="currentTab === 'charCard'" class="char-card-content">
        <div class="header">
            <h1>{{ character.name || 'æ–°è§’è‰²' }}</h1>
            <button @click="resetCharacter" style="margin-top: 10px; padding: 8px 15px; background-color: #ffaa00; color: white; border: none; border-radius: 4px; cursor: pointer;">é‡ç½®è§’è‰²æ•°æ®</button>
        </div>

        <div class="input-group">
            <label for="char-name">è§’è‰²åç§°</label>
            <input id="char-name" type="text" v-model="character.name" placeholder="è¾“å…¥ä½ çš„è§’è‰²åç§°">
        </div>

        <div class="derived-hp-gem">
            <div class="hp-item" style="grid-column: span 2;">
                <strong>ç”Ÿå‘½å€¼ (HP)</strong>
                <div class="hp-value">
                    <span :class="{'current-hp-value': character.currentHp < derived.maxHp}">{{ character.currentHp }}</span> / {{ derived.maxHp }}
                </div>
                <div class="hp-adjust">
                    <button @click="updateCurrentHp(-hpChangeValue)">-</button>
                    <input type="number" v-model.number="hpChangeValue" placeholder="æ•°å€¼">
                    <button class="heal" @click="updateCurrentHp(hpChangeValue)">+</button>
                </div>
            </div>
            
            <div class="derived-item">
                <strong>æ”»å‡»åŠ›</strong>
                <span class="derived-value">{{ derived.attack }}</span>
            </div>
            <div class="derived-item">
                <strong>å°„ç¨‹</strong>
                <span class="derived-value">{{ derived.range }}</span>
            </div>
            <div class="derived-item">
                <strong>ç§»åŠ¨åŠ›</strong>
                <span class="derived-value">{{ derived.movement }}</span>
            </div>
            <div class="derived-item">
                <strong>è¡ŒåŠ¨åŠ›</strong>
                <span class="derived-value">{{ derived.action }}</span>
            </div>
            
            <div class="gem-item" style="grid-column: span 2;">
                <strong>å®çŸ³</strong>
                <span class="gem-value">{{ character.gems }}</span>
                <div class="gem-adjust">
                    <button @click="updateGem(-1)">-1</button>
                    <button @click="updateGem(1)">+1</button>
                </div>
            </div>
        </div>

        <div class="stats-area">
            <h2>åŸºç¡€å±æ€§ (å·²åˆ†é…ç‚¹æ•°: {{ totalPoints }})</h2>
            <div v-for="(config, stat) in statConfigs" :key="stat" class="stat-item">
                <span class="stat-name">{{ config.name }}</span>
                <div class="stat-value">
                    <button @click="updateStat(stat, -1)" :disabled="character.stats[stat] <= 0">-</button>
                    <span class="stat-points">{{ character.stats[stat] }}</span>
                    <button @click="updateStat(stat, 1)" :disabled="character.stats[stat] >= config.max">+</button>
                </div>
            </div>
        </div>

        <div class="notes-area">
            <label for="notes">å¤‡æ³¨ / æŠ€èƒ½åˆ—è¡¨</label>
            <textarea id="notes" v-model="character.notes" placeholder="åœ¨æ­¤è®°å½•ä½ çš„ç¬”è®°æˆ–æŠ€èƒ½åˆ—è¡¨..."></textarea>
        </div>
    </div>

    <div v-if="currentTab === 'skillTree'" class="skill-tree-content">
        <h2>èŒä¸šæŠ€èƒ½æ ‘</h2>
        <select v-model="selectedClass">
            <option disabled value="">è¯·é€‰æ‹©ä¸€ä¸ªèŒä¸š</option>
            <option v-for="cls in availableClasses" :key="cls.id" :value="cls.id">
                {{ cls.name }}
            </option>
        </select>

        <div class="skill-tree-image-container">
            <img 
                v-if="selectedClass && skillTreeImages[selectedClass]" 
                :src="skillTreeImages[selectedClass]" 
                alt="Skill Tree Image"
                @dblclick.prevent
                @contextmenu.prevent
                
                @wheel.prevent="handleZoom"
                
                @mousedown="startDrag"
                @mousemove="onDrag"
                @mouseup="stopDrag"
                @mouseleave="stopDrag"

                @touchstart="handleTouchStart"
                @touchmove="handleTouchMove"
                @touchend="handleTouchEnd"
                
                :class="{'is-dragging': dragState.isDragging}"
                :style="imageTransformStyle"
            />
            <p v-else style="text-align: center; color: #666;">
                è¯·åœ¨ä¸Šæ–¹ä¸‹æ‹‰èœå•ä¸­é€‰æ‹©ä¸€ä¸ªèŒä¸šæ¥æŸ¥çœ‹å…¶æŠ€èƒ½æ ‘ã€‚
            </p>
        </div>
    </div>
</div>

<script>
    const { ref, reactive, computed, watch, onMounted, nextTick } = Vue;

    // ... [å¸¸é‡å®šä¹‰] ...
    const defaultStats = { str: 0, per: 0, con: 0, cha: 0, int: 0, dex: 0 };
    const statConfigs = {
        str: { name: 'åŠ›é‡', max: 20 }, per: { name: 'æ„ŸçŸ¥', max: 20 }, con: { name: 'ä½“è´¨', max: 20 }, 
        cha: { name: 'é­…åŠ›', max: 20 }, int: { name: 'æ™ºåŠ›', max: 20 }, dex: { name: 'æ•æ·', max: 20 },
    };
    const skillTreeImages = {
        mage: 'æ³•å¸ˆæŠ€èƒ½.png', assassin: 'åˆºå®¢æŠ€èƒ½.png', druid: 'å¾·é²ä¼ŠæŠ€èƒ½.png', 
        warrior: 'æˆ˜å£«æŠ€èƒ½.png', priest: 'ç‰§å¸ˆæŠ€èƒ½.png', hunter: 'çŒäººæŠ€èƒ½.png', 
        warlock: 'æœ¯å£«æŠ€èƒ½.png', knight: 'éª‘å£«æŠ€èƒ½.png', bard: 'åŸæ¸¸è¯—äººæŠ€èƒ½.png', 
        shaman: 'è¨æ»¡æŠ€èƒ½.png',
    };
    const availableClasses = [
        { id: 'mage', name: 'æ³•å¸ˆ' }, { id: 'assassin', name: 'åˆºå®¢' }, { id: 'druid', name: 'å¾·é²ä¼Š' }, 
        { id: 'warrior', name: 'æˆ˜å£«' }, { id: 'priest', name: 'ç‰§å¸ˆ' }, { id: 'hunter', name: 'çŒäºº' }, 
        { id: 'warlock', name: 'æœ¯å£«' }, { id: 'knight', name: 'éª‘å£«' }, { id: 'bard', name: 'åŸæ¸¸è¯—äºº' }, 
        { id: 'shaman', name: 'è¨æ»¡' },
    ];


    Vue.createApp({
        setup() {
            const currentTab = ref('charCard');
            const selectedClass = ref('');

            const character = reactive({
                name: '', stats: { ...defaultStats }, currentHp: 0, gems: 0, notes: ''
            });
            const hpChangeValue = ref(1);

            // è§†å›¾çŠ¶æ€
            const zoomState = reactive({ scale: 1.0, x: 0, y: 0 });
            const dragState = reactive({ isDragging: false, startX: 0, startY: 0, startTransX: 0, startTransY: 0 });
            
            // ğŸŒŸ æ–°å¢: è§¦æ‘¸ä¸“ç”¨çŠ¶æ€
            const touchState = reactive({
                initialDistance: 0, // åŒæŒ‡åˆå§‹è·ç¦»
                initialScale: 1.0,  // åŒæŒ‡å¼€å§‹æ—¶çš„ç¼©æ”¾æ¯”ä¾‹
                isPinching: false   // æ˜¯å¦æ­£åœ¨åŒæŒ‡ç¼©æ”¾
            });

            const imageTransformStyle = computed(() => {
                return {
                    transform: `translate3d(${zoomState.x}px, ${zoomState.y}px, 0) scale(${zoomState.scale})`,
                    // æ‹–æ‹½æˆ–è§¦æ‘¸æ—¶å…³é—­è¿‡æ¸¡ï¼Œä¿è¯è·Ÿæ‰‹
                    transition: (dragState.isDragging || touchState.isPinching) ? 'none' : 'transform 0.1s ease-out',
                };
            });

            const totalPoints = computed(() => Object.values(character.stats).reduce((sum, val) => sum + val, 0));
            const derived = computed(() => {
                const { str, per, con, dex, int } = character.stats;
                return { attack: str, range: per, maxHp: 6 + (con * 6), movement: 2 + Math.floor(dex / 2), action: 1 + int };
            });

            // --- ç”µè„‘ç«¯é¼ æ ‡æ‹–æ‹½ ---
            const startDrag = (event) => {
                if (event.button !== 0 || zoomState.scale === 1.0) return;
                dragState.isDragging = true;
                dragState.startX = event.clientX;
                dragState.startY = event.clientY;
                dragState.startTransX = zoomState.x;
                dragState.startTransY = zoomState.y;
                event.preventDefault(); 
            };
            const onDrag = (event) => {
                if (!dragState.isDragging) return;
                zoomState.x = dragState.startTransX + (event.clientX - dragState.startX);
                zoomState.y = dragState.startTransY + (event.clientY - dragState.startY);
                event.preventDefault(); 
            };
            const stopDrag = () => { dragState.isDragging = false; };

            // --- ç”µè„‘ç«¯æ»šè½®ç¼©æ”¾ ---
            const handleZoom = (event) => {
                event.preventDefault(); 
                if (dragState.isDragging) return;
                const rect = event.currentTarget.getBoundingClientRect();
                const direction = event.deltaY < 0 ? 1 : -1;
                const newScale = Math.min(4.0, Math.max(1.0, zoomState.scale + direction * 0.1));
                if (newScale === zoomState.scale) return;
                
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                const newX = zoomState.x + mouseX * (1 - newScale / zoomState.scale);
                const newY = zoomState.y + mouseY * (1 - newScale / zoomState.scale);

                zoomState.scale = newScale;
                if (newScale === 1.0) { zoomState.x = 0; zoomState.y = 0; }
                else { zoomState.x = newX; zoomState.y = newY; }
            };

            // --- ğŸŒŸ ç§»åŠ¨ç«¯è§¦æ‘¸é€»è¾‘ (åŒæŒ‡ç¼©æ”¾ + å•æŒ‡æ‹–æ‹½) ---
            
            // è®¡ç®—ä¸¤ç‚¹é—´è·ç¦»çš„è¾…åŠ©å‡½æ•°
            const getDistance = (touches) => {
                return Math.hypot(
                    touches[0].clientX - touches[1].clientX,
                    touches[0].clientY - touches[1].clientY
                );
            };

            const handleTouchStart = (event) => {
                if (event.touches.length === 1) {
                    // å•æŒ‡ï¼šå¼€å§‹æ‹–æ‹½ (å‰ææ˜¯å·²ç»æ”¾å¤§)
                    if (zoomState.scale > 1.0) {
                        dragState.isDragging = true;
                        dragState.startX = event.touches[0].clientX;
                        dragState.startY = event.touches[0].clientY;
                        dragState.startTransX = zoomState.x;
                        dragState.startTransY = zoomState.y;
                    }
                } else if (event.touches.length === 2) {
                    // åŒæŒ‡ï¼šå¼€å§‹ç¼©æ”¾
                    dragState.isDragging = false; // åŒæŒ‡æ—¶åœæ­¢æ‹–æ‹½
                    touchState.isPinching = true;
                    touchState.initialDistance = getDistance(event.touches);
                    touchState.initialScale = zoomState.scale;
                }
            };

            const handleTouchMove = (event) => {
                // å¿…é¡»é˜»æ­¢é»˜è®¤äº‹ä»¶ï¼Œå¦åˆ™æµè§ˆå™¨ä¼šæ»šåŠ¨é¡µé¢
                event.preventDefault(); 

                if (event.touches.length === 1 && dragState.isDragging) {
                    // å•æŒ‡ç§»åŠ¨ï¼šå¤„ç†å¹³ç§»
                    const dx = event.touches[0].clientX - dragState.startX;
                    const dy = event.touches[0].clientY - dragState.startY;
                    zoomState.x = dragState.startTransX + dx;
                    zoomState.y = dragState.startTransY + dy;
                } else if (event.touches.length === 2 && touchState.isPinching) {
                    // åŒæŒ‡ç§»åŠ¨ï¼šå¤„ç†ç¼©æ”¾
                    const currentDistance = getDistance(event.touches);
                    if (touchState.initialDistance > 0) {
                        const scaleRatio = currentDistance / touchState.initialDistance;
                        let newScale = touchState.initialScale * scaleRatio;
                        
                        // é™åˆ¶ç¼©æ”¾èŒƒå›´
                        newScale = Math.min(4.0, Math.max(1.0, newScale));
                        zoomState.scale = newScale;

                        // å¦‚æœç¼©å°å› 1.0ï¼Œè‡ªåŠ¨å¤ä½ä½ç½®
                        if (newScale === 1.0) {
                            zoomState.x = 0;
                            zoomState.y = 0;
                        }
                    }
                }
            };

            const handleTouchEnd = (event) => {
                // è§¦æ‘¸ç»“æŸï¼Œé‡ç½®çŠ¶æ€
                if (event.touches.length < 2) {
                    touchState.isPinching = false;
                }
                if (event.touches.length === 0) {
                    dragState.isDragging = false;
                }
            };

            // ç›‘å¬ Tab åˆ‡æ¢
            watch(currentTab, (newTab) => {
                if (newTab === 'charCard') {
                    zoomState.scale = 1.0; zoomState.x = 0; zoomState.y = 0;
                }
            });

            // ä¸šåŠ¡é€»è¾‘
            const updateStat = (stat, change) => {
                const current = character.stats[stat];
                if (change > 0 && current < statConfigs[stat].max) character.stats[stat]++;
                else if (change < 0 && current > 0) character.stats[stat]--;
            };
            const updateGem = (change) => character.gems = Math.max(0, character.gems + change);
            const updateCurrentHp = (change) => {
                character.currentHp = Math.min(derived.value.maxHp, Math.max(0, character.currentHp + change));
                hpChangeValue.value = 1;
            };
            const resetCharacter = () => {
                if (confirm('ç¡®å®šé‡ç½®?')) {
                    character.name = '';
                    
                    // 1. é‡ç½®å±æ€§ï¼ˆè¿™ä¼šè§¦å‘ watchï¼ŒæŠŠ HP å‡æˆ 1ï¼‰
                    character.stats = { ...defaultStats }; 
                    character.gems = 0;
                    character.notes = '';
                    
                    // 2. ã€å…³é”®ä¿®æ”¹ã€‘ä½¿ç”¨ nextTick 
                    // ç­‰å¾…ä¸Šé¢çš„ watch é—¹è…¾å®Œä¹‹åï¼Œå†å¼ºè¡ŒæŠŠ HP è®¾å®šä¸º 6
                    nextTick(() => {
                        character.currentHp = 6;
                    });
                }
            };

            onMounted(() => {
                const saved = localStorage.getItem('rpg-char-data-v4');
                const initialMaxHp = derived.value.maxHp;
                if (saved) {
                    const parsed = JSON.parse(saved);
                    character.name = parsed.name || '';
                    if (parsed.stats) character.stats = { ...defaultStats, ...parsed.stats };
                    character.gems = parsed.gems || 0;
                    character.notes = parsed.notes || '';
                    const maxHpOnLoad = 6 + (character.stats.con * 6);
                    character.currentHp = Math.min(maxHpOnLoad, parsed.currentHp !== undefined ? parsed.currentHp : maxHpOnLoad);
                } else { character.currentHp = initialMaxHp; }
            });
            watch(character, (newVal) => localStorage.setItem('rpg-char-data-v4', JSON.stringify(newVal)), { deep: true });
            watch(() => derived.value.maxHp, (n, o) => {
                const diff = n - o;
                if (diff > 0) character.currentHp += diff;
                else if (diff < 0) character.currentHp = Math.max(1, character.currentHp + diff);
            });

            return {
                currentTab, selectedClass, availableClasses, skillTreeImages, character, statConfigs, derived, totalPoints, hpChangeValue,
                zoomState, dragState, imageTransformStyle,
                handleZoom, startDrag, onDrag, stopDrag,
                // ğŸŒŸ æ–°å¢è¿”å›
                handleTouchStart, handleTouchMove, handleTouchEnd,
                updateStat, updateGem, updateCurrentHp, resetCharacter
            };
        }
    }).mount('#app');
</script>
</body>
</html>
